## 滴滴一面

### 项目相关
1. 为什么安卓比ios慢那么多tti： 
    1. 因为本身安卓的设备有很多低端机，拉低了整体的性能
    2. 本身安卓语言架构影响性能也会有所影响
2. lynx渲染原理：


### 八股文
1. type 和 interface 的区别
  - 声明合并： 
    - interface 多次定义同名接口会进行合并
    - type 不可重复定义同名类型，否则会报错
  - 扩展方式
    - interface 通过 extends 扩展接口
    - type 通过 & 组合多种类型
  - 灵活性
    - interface 仅可定义对象类型（函数、对象、类结构）
    - type 可定义任意类型：包括联合类型、原始类型 元组
  - 高级操作
    - type 可以支持映射类型、条件类型、typeof动态引用等高级操作
    ``` ts
      type Conditional<T> = T extends string ? 'string' : 'other';
      type MappedType = { [K in 'a' | 'b']: number };
      type User = typeof someExistingObject;     // 引用其他变量类型
    ```
  - 实现和继承
   - 类实现： 两者都可以通过 implement 来实现，但interface更符合语义
   - 泛型约束： 
   ``` ts
      interface Lengthwise { length: number; }
      function logLength<T extends Lengthwise>(arg: T) { ... }
    ```
2. 说说React diff原理
- 同级比较，不跨层级比较
- 比较同级节点类型，类型不同直接删除子树构建新树
- 通过key来标识同层级可复用的节点
- 相同类型的DOM元素：React 会 保留 DOM 节点，仅更新变化的属性。
- 相同的组件类型：如果组件类型相同，复用组件实例，触发更新生命周期，递归diff子节点
3. useCallback 和 useMemo 的区别
- useCallback可以认为是useMemo的语法糖
- usecallback： 缓存函数
- useMemo: 缓存一个高开销的计算结果







### coding
1. 实现函数
``` js
function f(b) {
  console.log(this.a, b);
} 
// Funtion.prototype.fakeBind
f.fakeBind = (a, inputB) => {
  if (inputB) {
    return () => f.bind({
      a: a.a
    })(inputB);
  }
  
  return (b) => f.bind({
    a: a.a
  })(b)
}

f.fakeBind({ a: 3 })(4); //=> 3, 4 
f.fakeBind({ a: 3 }, 10)(11); //=> 3, 10
```

2. 写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b,...,a+nb 的时间，然后写一个 myClear，停止上面的 mySetInterVal

``` js
function mySetInterval(fn, a, b) {
  const containerId = {
    timerId: null,
    count: 0,
    isClear: false;
  }

  function execFn = () => {
    const {
      timerId,
      isClear,
      time
    } = containerId
    if (isClear) return;
    fn();
    cotainerId.count = cotainerId.count + 1;
    const nextTime = a + cotainerId.count * b;
    containerId.timerId = setTimeout(execFn, cotainerId.time);
  }
  containerId.timerId = setTimeout(execFn, a)
  return containerId;
}

function myClear(container) {
  if (container.timerId) {
    clearTimeout(container.timerId);
    container.isClear = true
  }
}
```

3. console.log 输出题

``` js
async function async1 () {
  console.log('b');
  await async2();
  console.log('e')
}

function async2() {
  console.log('c')
}

console.log('a');
async1();

setTimeout(() => {
  console.log('g')
},0);

new Promise((res,rej) => {
  console.log('d')
  res();
}).then(() => {
  console.log('f')
})
```