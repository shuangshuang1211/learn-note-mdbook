### 高德

#### 项目
1. lynx框架技术细节，渲染原理和机制

2. 接手性能差的项目时，从哪些方面提出技术方案？

3. 三端一致性检测平台的原理

#### 八股文
1. React首次渲染的流程是怎样的？

2. 更新阶段如何检测变化？

3. 为什么引入hook？hook能否在条件语句中？
  在函数组件使用state而不需要转成类组件，增加复用性，公共逻辑可以抽象成自定义hook组件更简洁凝练，可以不使用this，useEffect 来处理副作用更方便
4. 如何改变js函数中的this指向，箭头函数的this指向有何特点？
  箭头函数不会创建自己的 this，而是会从外部作用域（即定义时的作用域）捕获 this 值。

#### coding

``` js

// 实现并发控制
function parallel(taskItems = [], taskHandler, concurrency = 3) {
  // 实现并发控制
  let currConcurrency = 0;
  let nextIndex = 0;
  const len = taskItems.length;
  const result = new Array(len);

  return new Promise((res, rej) => {
    // 没有超过concurreny
    function exectueFn() {
      while (currConcurrency < concurrency && nextIndex < len) {
        const currTaskItem = taskItems[nextIndex];
        let index = nextIndex;
        console.log('+++++ currTaskItem', currTaskItem);
        
        try {
          taskHandler(currTaskItem)
            .then((val) => {
                console.log('++++ handler then', index);
                result[index] = val;
            }).catch((err) => {
              result[index] = err;
            }).finally(() => {
              exectueFn();
              currConcurrency--;
              if (currConcurrency === 0 && nextIndex === 6) {
                res(result);
              }
            })
        } catch (err) {
          result[index] = err;
        }
        nextIndex++;
        currConcurrency++;
      }
      
    }
    
    if (len === 0) {
      res(result)
    } else {
      exectueFn();
    }
    
    
  });

}
const task = item => new Promise(resolve => setTimeout(() => {console.log(item); resolve(item)}, 2000))

parallel([1, 2, 3, 4, 5, 6], task, 2).then((result) => {
  console.log('++++', result)
})

```


``` js
// 实现并发控制
function parallel(taskItems = [], taskHandler, concurrency = 3) {
  // 实现并发控制
  let activeCount = 0;
  let taskArr = taskItems.map((item) => () => taskHandler(item));
  let activeTask = [];
  let resArr = [];
  let waitTask = [];

  function executeTask(task, resolve, reject) {
    console.log('+++++ task', task);
    try {
      task().then((val) => {
        resArr.push(val);
        if (resArr.length === taskItems.length) {
          resolve(resArr);
        }
        const nextTask = waitTask.shift();
        console.log('++++ nextTask', nextTask);
        if (nextTask) {
          executeTask(nextTask, resolve, reject)
        }
      });
    } catch (err) {
      console.log('+++++ err', err);
      reject('err')
    }
  }

  return new Promise((res, rej) => {
    // 没有超过concurreny
    for (let i = 0; i< taskArr.length; i++) {
      if (activeCount < concurrency) {
        activeCount++
        const currTask = taskArr[i];
        activeTask.push(currTask);
      } else {
        waitTask.push(taskArr[i])
      }
    }
    console.log('++++ wait', activeTask, waitTask);
    activeTask.map((currT) => {
      executeTask(currT, res, rej)
    })
    
  });

}
const task = item => new Promise(resolve => setTimeout(() => {console.log(item); resolve(item)}, 2000))

parallel([1, 2, 3, 4, 5, 6], task, 2).then((result) => {
  console.log('+++', result)
})
```