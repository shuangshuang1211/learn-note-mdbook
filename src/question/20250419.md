### 高德面试前准备

#### 1. 柯里化函数
``` js
function myCurry(fn) {
  const len = fn.length;
  return function curried(...ars) {
    if (ars.length < len) {
      return (...remainParams) => curried(...ars, ...remainParams);
    } else {
      return fn.call(this, ...ars);
    }
  };
}

function sum(a, b, c) {
  return a + b + c;
}

const currySum = myCurry(sum);

console.log("+++++ sum", currySum(2, 3, 4));
```


#### 2. 是用伪代码结合注释实现从右到左的弹幕，要求可以随机颜色、右侧起点位置、避免垂直重叠，支持插入用户实时输入的弹幕，支持暂停、继续弹幕、支持清屏

#### 3. 实现reduce
``` js
Array.prototype.myReduce = function (callFn, initVal) {
  const arr = this;
  let acc = initVal !== undefined ? initVal : arr[0];
  let startIndex = initVal !== undefined  ? 0 : 1;
  console.log("++++ ", acc, arr);
  
  for (let i = startIndex; i< arr.length; i++) {
    
    acc = callFn(acc, arr[i], i, arr)
  }
  
  return acc;
}

const sumArr = [1,2,3].myReduce((acc, cur) => cur + acc, 0)
console.log('++++ sumArr', sumArr);
```
#### 4. 实现响应式
#### 5. 实现柯里化
#### 6. 实现promise
#### 封装一个带缓存的请求函数.
``` js
class CachedRequest {
  constructor(options = {}) {
    // 初始化配置
    this.cache = new Map(); // 缓存存储
    this.defaultOptions = {
      ttl: 5 * 60 * 1000, // 默认缓存时间（5分钟）
      maxCacheSize: 100,  // 最大缓存条目数
      shouldCache: (response) => response.ok, // 仅缓存成功响应
      getCacheKey: (url, config) => `${url}?${new URLSearchParams(config.params)}`, // 默认缓存键
      ...options,
    };
  }

  // 发送请求（支持GET/POST等）
  async request(url, config = {}) {
    const { ttl, shouldCache, getCacheKey, ...requestConfig } = {
      ...this.defaultOptions,
      ...config,
    };

    // 生成唯一缓存键
    const cacheKey = getCacheKey(url, requestConfig);

    // 检查缓存是否存在且未过期
    const cachedItem = this.cache.get(cacheKey);
    if (cachedItem && Date.now() < cachedItem.expireAt) {
      return cachedItem.data.clone(); // 返回克隆的响应（防止多次读取流）
    }

    // 处理并发请求：已有相同请求进行中则等待结果
    if (cachedItem?.pendingPromise) {
      return cachedItem.pendingPromise;
    }

    try {
      // 创建新请求的Promise并标记为进行中
      const requestPromise = fetch(url, requestConfig);
      this.cache.set(cacheKey, { 
        pendingPromise: requestPromise,
        expireAt: Date.now() + ttl,
      });

      // 等待响应
      const response = await requestPromise;
      
      // 检查是否应缓存
      if (shouldCache(response)) {
        // 克隆响应以便多次使用
        const clone = response.clone();
        this.cache.set(cacheKey, {
          data: clone,
          expireAt: Date.now() + ttl,
        });
        this.cleanupCache(); // 清理过期缓存
      } else {
        this.cache.delete(cacheKey);
      }

      return response;
    } catch (error) {
      this.cache.delete(cacheKey); // 失败时移除缓存
      throw error;
    } finally {
      // 移除进行中标记
      const currentItem = this.cache.get(cacheKey);
      if (currentItem?.pendingPromise) {
        currentItem.pendingPromise = null;
      }
    }
  }

  // 清理过期和超量缓存
  cleanupCache() {
    const now = Date.now();
    // 删除过期缓存
    Array.from(this.cache.entries()).forEach(([key, item]) => {
      if (item.expireAt <= now) {
        this.cache.delete(key);
      }
    });

    // 删除超出数量限制的旧缓存
    if (this.cache.size > this.defaultOptions.maxCacheSize) {
      const keysToDelete = Array.from(this.cache.keys())
        .slice(0, this.cache.size - this.defaultOptions.maxCacheSize);
      keysToDelete.forEach(key => this.cache.delete(key));
    }
  }

  // 手动清除缓存
  clearCache(key) {
    if (key) {
      this.cache.delete(key);
    } else {
      this.cache.clear();
    }
  }
}
```
#### 手写防抖
#### 手写节流
#### 数组找最大重复项
#### 任务控制函数
#### 基于 React hooks实现一个搜索框，带推荐能力【审清题意】要求:1.Input组件支持受控与非授控场景，满足初始化默认值需求2.输入变化时，使用fetch请求服务获取联想推荐List,(选择item回填input，伪代码表义即可),要防抖，并定义一个 useDebounce(fn，delay,deps =D) hook 实现3.使用 推荐列表组件伪代码表义即可